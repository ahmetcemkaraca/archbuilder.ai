name: 🤖 Automated Security Suggestions

on:
  push:
    branches: [ develop, main ]
  pull_request:
    branches: [ develop, main ]
  schedule:
    # Run weekly security scan on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of security scan'
        required: true
        default: 'full'
        type: choice
        options:
        - full
        - quick
        - critical

jobs:
  security-analysis:
    name: 🔍 Security Analysis & Suggestions
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      pull-requests: write
      issues: write

    steps:
    - name: 📥 Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 🐍 Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        cache: 'pip'

    - name: 📦 Install Security Tools
      run: |
        pip install --upgrade pip
        pip install bandit[toml] safety semgrep
        pip install -r src/cloud-server/requirements.txt || true

    - name: 🔒 Run Bandit Security Scan
      run: |
        bandit -r src/cloud-server/app/ -f json -o bandit-report.json || true
        echo "BANDIT_RESULTS<<EOF" >> $GITHUB_ENV
        cat bandit-report.json >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: 🛡️ Run Safety Check
      run: |
        safety check --json --output safety-report.json || true
        echo "SAFETY_RESULTS<<EOF" >> $GITHUB_ENV
        cat safety-report.json >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: 🎯 Run Semgrep Analysis
      env:
        SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
      run: |
        semgrep --config=auto --json --output=semgrep-report.json src/cloud-server/app/ || true
        echo "SEMGREP_RESULTS<<EOF" >> $GITHUB_ENV
        cat semgrep-report.json >> $GITHUB_ENV
        echo "EOF" >> $GITHUB_ENV

    - name: 🔍 Custom Security Pattern Analysis
      run: |
        python << 'EOF'
        import json
        import os
        import subprocess
        from pathlib import Path

        # Custom security patterns to check
        patterns = {
            "missing_file_validation": {
                "pattern": r"UploadFile.*File\(",
                "check": r"validate_upload_file|validate_file_type",
                "message": "File upload endpoint missing security validation",
                "severity": "HIGH"
            },
            "hardcoded_secrets": {
                "pattern": r"(password|secret|key|token)\s*=\s*['\"][^'\"]+['\"]",
                "message": "Potential hardcoded secret detected",
                "severity": "CRITICAL"
            },
            "sql_injection_risk": {
                "pattern": r"\.execute\(.*\+.*\)",
                "message": "Potential SQL injection vulnerability",
                "severity": "HIGH"
            },
            "missing_input_validation": {
                "pattern": r"request\.(json|form|query)",
                "check": r"sanitize_|validate_",
                "message": "Input missing sanitization/validation",
                "severity": "MEDIUM"
            }
        }

        findings = []

        # Scan Python files
        for py_file in Path("src/cloud-server/app").rglob("*.py"):
            with open(py_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                lines = content.split('\n')

                for i, line in enumerate(lines, 1):
                    for pattern_name, config in patterns.items():
                        import re
                        if re.search(config["pattern"], line, re.IGNORECASE):
                            # Check if validation pattern exists
                            if "check" in config:
                                if not re.search(config["check"], content, re.IGNORECASE):
                                    findings.append({
                                        "file": str(py_file),
                                        "line": i,
                                        "pattern": pattern_name,
                                        "message": config["message"],
                                        "severity": config["severity"],
                                        "code": line.strip(),
                                        "suggestion": f"Add {config['check']} validation"
                                    })
                            else:
                                findings.append({
                                    "file": str(py_file),
                                    "line": i,
                                    "pattern": pattern_name,
                                    "message": config["message"],
                                    "severity": config["severity"],
                                    "code": line.strip()
                                })

        # Save findings
        with open("custom-security-findings.json", "w") as f:
            json.dump(findings, f, indent=2)

        print(f"Found {len(findings)} potential security issues")
        EOF

    - name: 📝 Generate Security Report
      run: |
        python << 'EOF'
        import json
        import os
        from datetime import datetime

        # Load all scan results
        findings = []

        # Load custom findings
        try:
            with open("custom-security-findings.json", "r") as f:
                custom_findings = json.load(f)
                findings.extend(custom_findings)
        except:
            pass

        # Generate markdown report
        report = f"""# 🔒 Security Analysis Report

        **Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
        **Total Issues Found:** {len(findings)}

        ## 📊 Summary by Severity

        """

        severities = {}
        for finding in findings:
            sev = finding.get('severity', 'UNKNOWN')
            severities[sev] = severities.get(sev, 0) + 1

        for sev, count in sorted(severities.items()):
            icon = {"CRITICAL": "🚨", "HIGH": "⚠️", "MEDIUM": "⚡", "LOW": "ℹ️"}.get(sev, "❓")
            report += f"- {icon} **{sev}**: {count} issues\n"

        report += "\n## 🎯 Detailed Findings\n\n"

        for i, finding in enumerate(findings, 1):
            severity_icon = {"CRITICAL": "🚨", "HIGH": "⚠️", "MEDIUM": "⚡", "LOW": "ℹ️"}.get(finding.get('severity', 'UNKNOWN'), "❓")

            report += f"""### {severity_icon} Finding #{i}: {finding.get('message', 'Security Issue')}

        **File:** `{finding.get('file', 'Unknown')}`
        **Line:** {finding.get('line', 'Unknown')}
        **Severity:** {finding.get('severity', 'Unknown')}

        ```python
        {finding.get('code', 'No code available')}
        ```

        """
            if 'suggestion' in finding:
                report += f"**💡 Suggestion:** {finding['suggestion']}\n"

            report += "\n---\n\n"

        # Save report
        with open("security-report.md", "w") as f:
            f.write(report)

        # Set environment variable for total issues
        with open(os.environ['GITHUB_ENV'], 'a') as f:
            f.write(f"TOTAL_SECURITY_ISSUES={len(findings)}\n")
        EOF

    - name: 📤 Create Security Issue (if critical findings)
      if: env.TOTAL_SECURITY_ISSUES != '0'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');

          // Read security report
          const report = fs.readFileSync('security-report.md', 'utf8');

          // Create or update security issue
          const issueTitle = `🔒 Automated Security Analysis - ${new Date().toISOString().split('T')[0]}`;

          // Check if similar issue exists
          const { data: issues } = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            labels: ['security', 'automated'],
            state: 'open'
          });

          const existingIssue = issues.find(issue =>
            issue.title.includes('Automated Security Analysis')
          );

          if (existingIssue) {
            // Update existing issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              body: `## 🔄 Updated Security Analysis\n\n${report}`
            });
          } else {
            // Create new issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: report,
              labels: ['security', 'automated', 'needs-review']
            });
          }

    - name: 🔧 Auto-Fix Common Issues
      if: github.event_name == 'push' && contains(github.ref, 'develop')
      run: |
        python << 'EOF'
        import os
        import re
        from pathlib import Path

        fixes_applied = []

        # Auto-fix pattern: Add file validation to upload endpoints
        for py_file in Path("src/cloud-server/app/routers").rglob("*.py"):
            with open(py_file, 'r', encoding='utf-8') as f:
                content = f.read()

            original_content = content

            # Check if file has UploadFile but no validation
            if "UploadFile" in content and "validate_upload_file" not in content:
                # Add import if missing
                if "from app.core.security.enhanced_security import get_enhanced_security" not in content:
                    # Find import section
                    lines = content.split('\n')
                    import_line_idx = -1
                    for i, line in enumerate(lines):
                        if line.startswith('from app.') and 'import' in line:
                            import_line_idx = i

                    if import_line_idx >= 0:
                        lines.insert(import_line_idx + 1, "from app.core.security.enhanced_security import get_enhanced_security")
                        content = '\n'.join(lines)

                # Add Path import if missing
                if "from pathlib import Path" not in content:
                    content = content.replace(
                        "from typing import",
                        "from pathlib import Path\nfrom typing import"
                    )

            if content != original_content:
                with open(py_file, 'w', encoding='utf-8') as f:
                    f.write(content)
                fixes_applied.append(f"Added security imports to {py_file}")

        if fixes_applied:
            print("Applied auto-fixes:")
            for fix in fixes_applied:
                print(f"  - {fix}")

            # Set flag for commit
            with open(os.environ['GITHUB_ENV'], 'a') as f:
                f.write("AUTO_FIXES_APPLIED=true\n")
        EOF

    - name: 💾 Commit Auto-Fixes
      if: env.AUTO_FIXES_APPLIED == 'true'
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "Security Auto-Fix Bot"
        git add -A
        git commit -m "🔒 security: auto-fix missing security imports and validations

        - Added enhanced security imports to upload endpoints
        - Ensured file validation is available for all UploadFile handlers
        - Applied automated security patches

        Generated by: .github/workflows/security-suggestions.yml" || exit 0
        git push || echo "No changes to push"

    - name: 📊 Upload Security Reports as Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: security-analysis-reports
        path: |
          security-report.md
          custom-security-findings.json
          bandit-report.json
          safety-report.json
          semgrep-report.json
        retention-days: 30

    - name: 📈 Comment on PR (if applicable)
      if: github.event_name == 'pull_request' && env.TOTAL_SECURITY_ISSUES != '0'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('security-report.md', 'utf8');

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: `## 🔒 Automated Security Analysis Results\n\n${report.substring(0, 60000)}...`  // Limit comment size
          });
